@article{2021-09-1-razaSOK,
  type = {Systemization of {{Knowledge}} ({{SoK}})},
  title = {Function-as-a-{{Service}}: {{From An Application Developer}}'s {{Perspective}}},
  author = {Raza, Ali and Matta, Ibrahim and Akhtar, Nabeel and Kalavri, Vasiliki and Isahagian, Vatche},
  year = {2021},
  month = sep,
  journal = {Journal of Systems Research},
  volume = {1},
  number = {1},
  issn = {2770-5501},
  doi = {10.5070/SR31154815},
  url = {https://escholarship.org/uc/item/1wg7h0qf},
  urldate = {2021-09-21},
  abstract = {A survey paper on the state of serverless computing from a developer's perspective.},
  area = {Serverless Systems},
  langid = {english},
  review_url = {https://openreview.net/forum?id=VdWaMgaTKtX}
}

@article{2021-09-2-whittakerSOK,
  type = {Systemization of {{Knowledge}} ({{SoK}})},
  title = {A {{Generalized Multi-Leader State Machine Replication Tutorial}}},
  author = {Whittaker, Michael and Giridharan, Neil and Szekeres, Adriana and Hellerstein, Joseph and Stoica, Ion},
  year = {2021},
  month = sep,
  journal = {Journal of Systems Research},
  volume = {1},
  number = {1},
  issn = {2770-5501},
  doi = {10.5070/SR31154817},
  url = {https://escholarship.org/uc/item/9w79h2jg},
  urldate = {2021-09-21},
  abstract = {Everything you always wanted to know about generalized multi-leader state machine replication protocols but were afraid to ask.},
  area = {Distributed Consensus},
  langid = {english},
  review_url = {https://openreview.net/forum?id=4Xo8nv5DNS}
}

@article{2021-09-3-whittakerSolution,
  type = {Solution},
  title = {Matchmaker {{Paxos}}: {{A Reconfigurable Consensus Protocol}}},
  author = {Whittaker, Michael and Giridharan, Neil and Szekeres, Adriana and Hellerstein, Joseph and Howard, Heidi and Nawab, Faisal and Stoica, Ion},
  year = {2021},
  month = sep,
  journal = {Journal of Systems Research},
  volume = {1},
  number = {1},
  issn = {2770-5501},
  doi = {10.5070/SR31154842},
  url = {https://escholarship.org/uc/item/8wk3343k},
  urldate = {2021-09-21},
  abstract = {Donut Paxos is a reconfigurable consensus protocol that leverages ideas from Vertical Paxos, DPaxos, and Flexible Paxos.},
  area = {Distributed Consensus},
  artifacts_url = {https://github.com/mwhittaker/frankenpaxos/},
  langid = {english},
  review_url = {https://openreview.net/forum?id=bXe1agiq9LN}
}

@article{2021-11-4-jacobTool,
  type = {Tools/{{Benchmark}}},
  title = {Designing {{Replicable Networking Experiments With Triscale}}},
  author = {Jacob, Romain and Zimmerling, Marco and Boano, Carlo Alberto and Vanbever, Laurent and Thiele, Lothar},
  year = {2021},
  month = nov,
  journal = {Journal of Systems Research},
  volume = {1},
  number = {1},
  issn = {2770-5501},
  doi = {10.5070/SR31155408},
  url = {https://escholarship.org/uc/item/63n4s9w2},
  urldate = {2021-11-15},
  abstract = {When designing their performance evaluations, networking researchers often encounter questions such as: How long should a run be? How many runs to perform? How to account for the variability across multiple runs? What statistical methods should be used to analyze the data? Despite their best intentions, researchers often answer these questions differently, thus impairing the replicability of their evaluations and the confidence in their results. In this paper, we propose a concrete methodology for the design and analysis of performance evaluations. Our approach hierarchically partitions the performance evaluation into three timescales, following the principle of separation of concerns. The idea is to understand, for each timescale, the temporal characteristics of variability sources, and then to apply rigorous statistical methods to derive performance results with quantifiable confidence in spite of the inherent variability. We implement this methodology in a software framework called TriScale. For each performance metric, TriScale computes a variability score that estimates, with a given confidence, how similar the results would be if the evaluation were replicated; in other words, TriScale quantifies the replicability of evaluations. We showcase the practicality and usefulness of TriScale on four different case studies demonstrating that TriScale helps to generalize and strengthen published results. Improving the standards of replicability in networking is a complex challenge. This paper is an important contribution to this endeavor; it provides networking researchers with a rational and concrete experimental methodology rooted in sound statistical foundations. The first of its kind.},
  area = {Networking},
  artifacts_url = {https://github.com/romain-jacob/triscale},
  langid = {english},
  review_url = {https://openreview.net/forum?id=c1LNi8CTPy6}
}

@article{2022-03-07-zakiSolution,
  type = {Solution},
  title = {{{ALCC}}: {{Migrating Congestion Control To The Application Layer In Cellular Networks}}},
  shorttitle = {{{ALCC}}},
  author = {Zaki, Yasir and Asim, Rohail and Khan, Muhammad and Iyer, Shiva and Ahmad, Talal and Potsch, Thomas and Subramanian, Lakshmi},
  year = {2022},
  month = mar,
  journal = {Journal of Systems Research},
  volume = {2},
  number = {1},
  issn = {2770-5501},
  doi = {10.5070/SR32156656},
  url = {https://escholarship.org/uc/item/3989w2s4},
  urldate = {2022-03-07},
  abstract = {TCP is known to perform poorly in cellular network environ- ments. Yet, most mobile applications are explicitly built on the conventional TCP stack or implicitly leverage TCP tun- nels to various cellular middleboxes, including performance- enhancing proxies, application-specific edge proxies, VPN proxies and NAT boxes. Despite significant advances in the design of new congestion control (CC) protocols for cellular networks, deploying these protocols without bypassing the underlying TCP tunnels has remained a challenging propo- sition. This paper proposes the design of a new Application Layer Congestion Control (ALCC) framework that allows any new CC protocol to be implemented easily at the application layer, within or above an application-layer protocol that sits atop a legacy TCP stack. It drives it to deliver approximately the same as the native performance. The ALCC socket sits on top of a traditional TCP socket. Still, it can leverage the large congestion windows opened by TCP connections to carefully execute an application-level CC within the window bounds of the underlying TCP connection. This paper demonstrates how ALCC can be applied to three well-known cellular CC pro- tocols: Verus, Copa, and Sprout. For these protocols, ALCC can achieve comparable throughput and delay characteristics (within 3-10\%) as the native protocols at the application layer across different networks and traffic conditions. ALCC al- lows a server-side implementation of these protocols with no client modifications and with zero bytes overhead. The ALCC framework can be easily integrated with off-the-shelf applications such as file transfers and video streaming.},
  area = {Networking},
  artifacts_url = {https://github.com/comnetsAD/ALCC},
  langid = {english},
  review_url = {https://openreview.net/forum?id=moVPhXtxQo7}
}

@article{2022-06-22-seshagiriSoK,
  type = {{{SoK}}},
  ids = {seshagiri2022SOK},
  title = {Identifying {{Mismatches Between Microservice Testbeds}} and {{Industrial Perceptions}} of {{Microservices}}},
  author = {Seshagiri, Vishwanath and Huye, Darby and Liu, Lan and Wildani, Avani and Sambasivan, Raja R.},
  year = {2022},
  month = jun,
  journal = {Journal of Systems Research},
  volume = {2},
  number = {1},
  issn = {2770-5501},
  doi = {10.5070/SR32157839},
  url = {https://escholarship.org/uc/item/5v3489k8},
  urldate = {2022-06-22},
  abstract = {Industrial microservice architectures vary so wildly in their characteristics, such as size or communication method, that comparing systems is difficult and often leads to confusion and misinterpretation. In contrast, the academic testbeds used to conduct microservices research employ a very constrained set of design choices. This lack of systemization in these key design choices when developing microservice architectures has led to uncertainty over how to use experiments from testbeds to inform practical deployments and indeed whether this should be done at all. We conduct semi-structured interviews with industry participants to understand the representativeness of existing testbeds' design choices. Surprising results included the presence of cycles in industry deployments, as well as a lack of clarity about the presence of hierarchies. We then systematize the possible design choices we learned about from the interviews, and identify important mismatches between our interview results and testbeds' designs that will inform future, more representative testbeds.},
  area = {Serverless},
  langid = {english},
  review_url = {https://openreview.net/forum?id=SzgbRfqFRY}
}

@article{2022-07-21-licciardelloSolution,
  type = {Solution},
  ids = {licciardello2022Solution},
  title = {Prepare Your Video for Streaming with {{Segue}}},
  author = {Licciardello, Melissa and Humbel, Lukas and Rohr, Fabian and Gr{\"u}ner, Maximilian and Singla, Ankit},
  year = {2022},
  month = jul,
  journal = {Journal of Systems Research},
  volume = {2},
  number = {1},
  doi = {10.5070/SR32158113},
  url = {https://escholarship.org/uc/item/8m39f25q},
  urldate = {2022-07-21},
  abstract = {We identify new opportunities in video streaming, involving the joint consideration of offline video chunking and on-line rate adaptation. Due to a video's complexity varyingover time, certain parts are more likely to cause performanceimpairments during playback with a particular rate adaptationalgorithm. To address such an issue, we propose Segue ,which carefully uses variable-length video segments, and augment specific segments with additional bitrate tracks. The keynovelty of our approach is in making such decisions basedon the video's time-varying complexity and the expected rateadaptation behavior over time. We propose and implementseveral methods for such adaptation-aware chunking. Ourresults show that Segue substantially reduces rebufferingand quality fluctuations, while maintaining video quality delivered; Segue improves QoE by 9\% on average, and by 22\%in low-bandwidth conditions. Finally, we view our problemframing as a first step in a new thread on algorithmic anddesign innovation in video streaming, and leave the readerwith several interesting open questions.},
  area = {Networking},
  artifacts_url = {https://github.com/melADTR/Segue},
  langid = {english},
  review_url = {https://openreview.net/forum?id=iUU6Qr3eQd6}
}

@article{2022-08-29-sinhaSolution,
  type = {Solution},
  ids = {sinha2022Solution},
  title = {End-to-End Scheduling of Real-Time Task Pipelines on Multiprocessors},
  author = {Sinha, Soham and West, Richard},
  year = {2022},
  month = aug,
  journal = {Journal of Systems Research},
  volume = {2},
  number = {1},
  issn = {2770-5501},
  doi = {10.5070/SR32158647},
  url = {https://escholarship.org/uc/item/2h11n6xj},
  urldate = {2022-08-29},
  abstract = {Task pipelines are common in today's embedded systems, as data moves from source to sink in sensing-processing-actuation task chains. A real-time task pipeline is constructed by connecting a series of periodic tasks with data buffers. In a time-critical system, end-to-end timing and data-transfer properties of a task pipeline must be guaranteed. A guarantee could be mathematically expressed by assigning constraints to the tasks of a pipeline. However, deriving task scheduling parameters to meet end-to-end guarantees is an NP-hard constraint optimization problem. Hence, a traditional constraint solver is not a suitable runtime solution. In this paper, we present a heuristic constraint solver algorithm, CoPi, to derive the execution times and periods of pipelined tasks that meet the end-to-end constraints and schedulability requirements. We consider two upper bound constraints on a task pipeline: end-to-end delay and loss-rate. After satisfying these constraints, CoPi schedules a pipeline as a set of asynchronous and data independent periodic tasks, under the rate-monotonic scheduling algorithm. Simulations show that CoPi has a comparable pipeline acceptance ratio and significantly better runtime than open-source MINLPsolvers. Furthermore, we use CoPi to map multiple task pipelines to a multiprocessor system. We demonstrate that a partitioned multiprocessor scheduling algorithm coupled with CoPi accommodates dynamically appearing pipelines, while attempting to minimize task migrations.},
  area = {Real-time and Cyber-physical Systems},
  artifacts_url = {https://github.com/sohamm17/pipe\textsubscript{s}chedule},
  langid = {english},
  review_url = {https://openreview.net/forum?id=icP8jy6ayy8}
}

@article{2022-09-28-LeznikSoK,
  type = {Sok},
  title = {The {{Great GAN Bake Off}}, {{An Extensive Systematic Evaluation}} of {{Generative Adversarial Network Architectures}} for {{Time Series Synthesis}}},
  author = {Leznik, Mark and Lochner, Arne and Wesner, Stefan and Domaschka, J{\"o}rg},
  year = {2022},
  month = sep,
  journal = {Journal of Systems Research},
  volume = {2},
  number = {1},
  issn = {2770-5501},
  doi = {10.5070/SR32159045},
  url = {https://escholarship.org/uc/item/33h6w78g},
  urldate = {2022-09-28},
  abstract = {There is no standard approach to compare the success ofdifferent neural network architectures utilized for time seriessynthesis. This hinders the evaluation and decision process,as to which architecture should be leveraged for an unknowndata set. We propose a combination of metrics, which empiri-cally evaluate the performance of neural network architecturestrained for time series synthesis. With these measurementswe are able to account for temporal correlations, spatial cor-relations and mode collapse issues within the generated timeseries.We further investigate the interaction of different genera-tor and discriminator architectures between each other. Theconsidered architectures include recurrent neural networks,temporal convolutional networks and transformer-based net-works. So far, the application of transformer-based models islimited for time series synthesis. Hence, we propose a newtransformer-based architecture, which is able to synthesisetime series. We evaluate the proposed architectures and theircombinations in over 500 experiments, amounting to over2500 computing hours. We provide results for four data sets,one univariate and three multivariate. The data sets vary withregard to length, as well as patterns in temporal and spatialcorrelations.We use our metrics to compare the performance of genera-tive adversarial network architectures for time series synthesis.To verify our findings we utilize quantitative and qualitativeevaluations. Our results indicate that temporal convolutionalnetworks currently outperform recurrent neural network andtransformer based approaches with regard to fidelity and flex-ibility of the generated time series data. Temporal convolu-tional network architecture are the most stable architecture fora mode collapse prone data set. The performance of the trans-former models strongly depends on the data set characteristics,it struggled to synthesise data sets with high temporal andspatial correlations. Discriminators with recurrent networkarchitectures suffer from vanishing gradients. We also show,that the performance of the generative adversarial networksdepends more on the discriminator rather than the generator.},
  area = {Systems for ML and ML for Systems},
  langid = {english},
  review_url = {https://openreview.net/forum?id=S6fWW0G9t0t}
}

@article{2022-10-24-stathakopoulouSolution,
  type = {Solution},
  ids = {Sol_Mir-BFT},
  title = {Mir-{{BFT}}: {{Scalable}} and {{Robust BFT}} for {{Decentralized Networks}}},
  shorttitle = {Mir-{{BFT}}},
  author = {Stathakopoulou, Chrysoula and David, Tudor and Pavlovic, Matej and Vukoli{\'c}, Marko},
  year = {2022},
  month = oct,
  journal = {Journal of Systems Research},
  volume = {2},
  number = {1},
  issn = {2770-5501},
  doi = {10.5070/SR32159278},
  url = {https://escholarship.org/uc/item/36g369xq},
  urldate = {2022-10-24},
  abstract = {This paper presents Mir-BFT, a robust Byzantine fault-tolerant (BFT) total order broadcast protocol aimed at maxi-mizing throughput on wide-area networks (WANs), targetingdeployments in decentralized networks, such as permissionedand Proof-of-Stake permissionless blockchain systems.Mir-BFT is the first BFT protocol that allows multiple lead-ers to propose request batches independently (i.e., parallelleaders), while effectively precluding performance degrada-tion due to request duplication by rotating the assignmentof a partitioned request hash space to leaders. As this mech-anism removes the single-leader bandwidth bottleneck andexposes a computation bottleneck related to authenticatingclients even on a WAN, our protocol further boosts through-put using a client signature verification sharding optimization.Our evaluation shows that Mir-BFT outperforms state-of-the-art single-leader protocols and orders more than 60000 signedBitcoin-sized (500-byte) transactions per second on a widelydistributed setup (100 nodes, 1 Gbps WAN) with typical la-tencies of few seconds. Moreover, our evaluation exposesthe impact of duplicate requests on parallel leader protocolswhich Mir-BFT eliminates. We also evaluate Mir-BFT un-der different crash and Byzantine faults, demonstrating itsperformance robustness.Mir-BFT relies on classical BFT protocol constructs, whichsimplifies reasoning about its correctness. Specifically, Mir-BFT is a generalization of the celebrated and scrutinizedPBFT protocol. In a nutshell, Mir-BFT follows PBFT ``safety-wise'', with changes needed to accommodate novel featuresrestricted to PBFT liveness.},
  area = {Distributed Consensus},
  artifacts_url = {https://github.com/hyperledger-labs/mirbft/tree/research},
  langid = {english},
  review_url = {https://openreview.net/forum?id=kCKRUcUGSup}
}
